import numpy as np
import matplotlib.pyplot as plt

def compute_coverage_len(y, y_lower, y_upper):
    """Compute average coverage and length of prediction intervals
    Originally from: https://github.com/yromano/cqr.git

    Args:
        y_test (np.array): true labels
        y_lower (np.array): estimated lower bound for the labels
        y_upper (np.array): estimated upper bound for the labels

    Returns:
        left_coverage :  average left coverage
        coverage (float): average coverage
        avg_length :  average prediction interval length
    """
    in_the_range = np.sum((y >= y_lower) & (y <= y_upper))
    above_lower_bound = np.sum(y >= y_lower)

    left_coverage = above_lower_bound / len(y)
    coverage = in_the_range / len(y)
    avg_length = np.mean(abs(y_upper - y_lower))

    return left_coverage, coverage, avg_length


def compute_quantile(scores, alpha):
    """compute quantile from the scores

    Args:
        scores (list or np.array): scores of calibration data
        alpha (float): error rate in conformal prediction
    """
    n = len(scores)

    return np.quantile(scores, np.ceil((n+1)*(1-alpha))/n)


def calculate_weight(rho, idx_test, idx_cal):
    """calculating weights for nex-SCP

    Args:
        rho (float)
        idx_test: index of test data points
        idx_cal: index od calibration data points

    Returns:
        array of weights
    """
    return rho**np.abs(idx_test - idx_cal)

def compute_quantiles_nex(rho, scores, idx_test, idx_cal, alpha):
    """compute quantile from the scores for nex-SCP 

    Args:
        rho: for weight calculation
        scores: scores of calibration data
        idx_test: index of test data points
        idx_cal: index od calibration data points
        alpha: error rate in conformal prediction

    Returns:
        array of quantiles corresponding to each test point
    """
    sorted_scores_idx = scores.argsort(axis=0)
    sorted_scores = scores[sorted_scores_idx]

    q_list = []
    pos_list = []
    for i in idx_test: 

        weights = calculate_weight(rho, i, idx_cal[sorted_scores_idx]) 
        weights_normalized = weights/(weights.sum()+1)
        pos_i = np.where(weights_normalized.cumsum() >= 1-alpha)[0][0]
        qi = sorted_scores[pos_i]
        q_list.append(qi[0][0])
        pos_list.append(pos_i)
    return np.array(q_list).reshape((-1,1))

def validate_calibration_epoch(calval_data, val_idx, cal_idx, DCNN, MQDCNN, alpha, rho):   
    """checking whether calibration works appropriately

    Args:
        calval_data (_type_): calibration+validation data
        val_idx: index of validation data points
        cal_idx: index of calibration data points
        DCNN: trained DCNN
        MQDCNN: trained MQDCNN
        alpha (float): error rate in conformal prediction
        rho (float): for weight calculation in nex-SCP

    Returns:
        average left coverage, coverage, and prediction interval length for SCP, nex-SCP, and CQR
    """
    X_val, X_cal = calval_data["X"][val_idx], calval_data["X"][cal_idx]
    y_val, y_cal = calval_data["y"][val_idx], calval_data["y"][cal_idx]
    idx_val, idx_cal = calval_data["index"][val_idx], calval_data["index"][cal_idx]

    y_hat_cal = DCNN.predict(x=X_cal, verbose=0)
    y_hat_val = DCNN.predict(x=X_val, verbose=0)
    scores = np.abs(y_cal - y_hat_cal) 
    q = compute_quantile(scores, alpha)
    q_array = compute_quantiles_nex(rho, scores, idx_val, idx_cal, alpha)
    SCP = compute_coverage_len(y_val, y_hat_val-q, y_hat_val+q)
    nex_SCP = compute_coverage_len(y_val, y_hat_val-q_array, y_hat_val+q_array)

    y_hat_cal_CQR = MQDCNN.predict(x=X_cal, verbose=0)
    y_hat_val_CQR = MQDCNN.predict(x=X_val, verbose=0)
    scores_low = y_hat_cal_CQR[0] - y_cal
    scores_high = y_cal - y_hat_cal_CQR[1] 
    scores_CQR = np.maximum(scores_low, scores_high)
    q_CQR = compute_quantile(scores_CQR, alpha)
    CQR = compute_coverage_len(y_val, y_hat_val_CQR[0] - q_CQR, y_hat_val_CQR[1] + q_CQR)
    return SCP, nex_SCP, CQR

def reform_test_data(test_data):
    """return the last datapoint (X, y, index) of each series in test data 

    Args:
        test_data: test data

    Returns:
        three lists of X's, y's, and indexes of last datapoints in test data
    """
    X_test, y_test, idx_test = [], [], []
    for id in np.unique(test_data["id"]):
        X_test.append(test_data["X"][test_data["id"]==id][-1])
        y_test.append(test_data["y"][test_data["id"]==id][-1])
        idx_test.append(test_data["index"][test_data["id"]==id][-1])
    return np.array(X_test), np.array(y_test), np.array(idx_test) 


def plot_sorted_targets_intervals(datset_name, results):
    """plot actual test RUL labels with their prediction intervals  

    Args:
        datset_name (str): such as CMAPSS1
        results (dict): a dictionaryt containing ground truth, lower and upper bound of intervals
        generated by three CP methods
    """
    
    y = results[datset_name]["y_test"]
    sorted_y_idx = y.argsort(axis=0)
    sorted_y = y[sorted_y_idx.reshape(-1)]
    fig = plt.figure(figsize=(40, 10))
    plt.rcParams["font.family"] = "Times New Roman"
    plt.rcParams["font.size"] = 35
    i = 1
    methods = ["SCP", "nex-SCP", "CQR"]
    colors = ["blue", "red", "green"]
    for m, c in zip(methods, colors):
        lower = results[datset_name][m][0]
        upper = results[datset_name][m][1]
        sorted_low = lower[sorted_y_idx]
        sorted_up = upper[sorted_y_idx]
        ax = fig.add_subplot(1,3,i)
        ax.fill_between(range(len(sorted_y)), sorted_low.reshape(-1), sorted_up.reshape(-1), color=c, alpha=0.2, label=m)
        ax.plot(range(len(sorted_y)), sorted_y, 'ok', label="Ground truth RULs", alpha=0.6)
        plt.ylim([0,180])
        plt.xlabel('Test units with increasing RUL')
        plt.legend(loc='upper left')
        i = i + 1


def plot_validate_calibration(datset_name, results):
    
    fig = plt.figure(figsize=(40, 10))
    plt.rcParams["font.family"] = "Times New Roman"
    plt.rcParams["font.size"] = 35
    methods = ["SCP", "nex-SCP", "CQR"]
    colors = ["blue", "red", "green"]
    Labels = ["Average lower bound coverage", "Average coverage", "Average interval length"]
    for i in range(3):
        ax = fig.add_subplot(1,3,i+1)
        for m, c in zip(methods, colors):
            ax.hist(np.stack(results[datset_name][m])[:,i], color=c, alpha=0.2, label=m)
        plt.xlabel(Labels[i])
        plt.legend(loc='upper left')

def PHM_score(y, y_hat):
    d = y_hat - y
    return np.sum(np.where(d < 0, np.expm1(-d/13.), np.expm1(d/10.)))
        
